// Alternative alignment function with 2 suffix (Edlib).

// Shasta.
#include "Assembler.hpp"
using namespace shasta;

// Suppress some warning messages generated by Edlib.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"

// Edlib.
#include "edlib.hpp"
using namespace edlib;


// This uses Edlib to align two oriented reads.
// Edlib does not support local alignment
// so we use a 3-step process that produces less than
// optimal alignments.

void Assembler::alignOrientedReads2(
    OrientedReadId orientedReadId0,
    OrientedReadId orientedReadId1,
    Alignment& alignment,
    AlignmentInfo& alignmentInfo)
{
    // Gather the KmerId's of orientedRead0.
    const span<CompressedMarker> markers0 =
        markers[orientedReadId0.getValue()];
    vector<KmerId> kmerIds0;
    kmerIds0.reserve(markers0.size());
    for(const CompressedMarker marker: markers0) {
        kmerIds0.push_back(marker.kmerId);
        // cout << "kmerIds0: " << marker.kmerId << endl;
    }

    // Gather the KmerId's of orientedRead1.
    const span<CompressedMarker> markers1 =
        markers[orientedReadId1.getValue()];
    vector<KmerId> kmerIds1;
    kmerIds1.reserve(markers1.size());
    for(const CompressedMarker marker: markers1) {
        kmerIds1.push_back(marker.kmerId);
        // cout << "kmerIds1: " << marker.kmerId << endl;
    }

    // Edlib alignment options.
    // For the first two steps, don't compute the alignment paths and use infix mode.
    EdlibAlignConfig config;
    config.k = -1;
    config.mode = EDLIB_MODE_HW;
    config.task = EDLIB_TASK_LOC;
    config.additionalEqualities = 0;
    config.additionalEqualitiesLength = 0;

    // Step 1: EDLIB_MODE_HW, EDLIB_TASK_LOC
    // with read0 as the query and read1 as the target.
    // Get approximate alignment range in read1.
    EdlibAlignResult result = edlibAlign<KmerId, KmerId>(
        kmerIds0.data(), kmerIds0.size(),
        kmerIds1.data(), kmerIds1.size(),
        config);
    if(result.status != EDLIB_STATUS_OK) {
        throw runtime_error("Error during edlibAlign.");
    }
    const int begin1 = result.startLocations[0];
    const int end1 = result.endLocations[0];



    // Step 2: EDLIB_MODE_HW, EDLIB_TASK_LOC
    // with read1 as the query and read1 as the target.
    // Get approximate alignment range in read1.
    result = edlibAlign<KmerId, KmerId>(
        kmerIds1.data(), kmerIds1.size(),
        kmerIds0.data(), kmerIds0.size(),
        config);
    if(result.status != EDLIB_STATUS_OK) {
        throw runtime_error("Error during edlibAlign.");
    }
    const int begin0 = result.startLocations[0];
    const int end0 = result.endLocations[0];



    // Step 3: EDLIB_MODE_NW, EDLIB_TASK_PATH
    // for the read portions found in the first two steps.
    config.mode = EDLIB_MODE_NW;
    config.task = EDLIB_TASK_PATH;
    result = edlibAlign<KmerId, KmerId>(
        kmerIds0.data() + begin0, kmerIds0.size() - (end0-begin0),
        kmerIds1.data() + begin1, kmerIds1.size() - (end1-begin1),
        config);
    if(result.status != EDLIB_STATUS_OK) {
        throw runtime_error("Error during edlibAlign.");
    }
    SHASTA_ASSERT(result.numLocations == 1);
    SHASTA_ASSERT(result.startLocations[0] == 0);

    // Fill in the alignment.
    alignment.clear();
    uint32_t ordinal0 = begin0;
    uint32_t ordinal1 = begin1;
    for(int i=0; i<result.alignmentLength; i++) {
        const unsigned char code = result.alignment[i];
        switch(code) {
        case EDLIB_EDOP_MATCH:
            alignment.ordinals.push_back({ordinal0++, ordinal1++});
            break;
        case EDLIB_EDOP_MISMATCH:
            ++ordinal0;
            ++ordinal1;
            break;
        case EDLIB_EDOP_INSERT:
            ++ordinal0;
            break;
        case EDLIB_EDOP_DELETE:
            ++ordinal1;
            break;
        default:
            SHASTA_ASSERT(0);
        }

    }
    // Free the alignment object.
    edlibFreeAlignResult(result);

    // Store the alignment info.
    alignmentInfo.create(alignment, uint32_t(markers0.size()), uint32_t(markers1.size()));

}
#pragma GCC diagnostic pop
