# Default configuration file for a Shasta assembly.
# The intent is that this will be tuned for a
# human assembly from Oxford Nanopore reads and coverage around 60x.
# Assembly parameter changes may be necessary
# for optimal performance under different conditions.

# Usage documentation is accessible here:
# https://chanzuckerberg.github.io/shasta/

# For information on how to set up a test run for which
# performance is not essential see here:
# https://chanzuckerberg.github.io/shasta/RunningSmall.html

# For information on how to set up a run for best performance see here:
# https://chanzuckerberg.github.io/shasta/Running.html



[Reads]

# The minimum read length. Reads shorter than this
# are skipped on input.
minReadLength = 10000

# Parameters for flagPalindromicReads.
# See the code for their meaning.
palindromicReads.maxSkip = 100
palindromicReads.maxMarkerFrequency = 10
palindromicReads.alignedFractionThreshold = 0.1
palindromicReads.nearDiagonalFractionThreshold = 0.1
palindromicReads.deltaThreshold = 100



[Kmers]

# This section contains parameters that control the
# generation of k-mers to be used as markers.

# The length of the k-mers used as markers.
k = 10

# The probability that a k-mer is a marker.
# This is approximately equal to the fraction
# of k-mers that will be used as markers.
probability = 0.1

# If suppressHighFrequencyMarkers is True, high frequency k-mers 
# are not used as markers. High frequency k-mers are those 
# with enrichment greater than the value specified by enrichmentThreshold.
# Enrichment is ratio of k-mer frequency in reads to random.
suppressHighFrequencyMarkers = False
enrichmentThreshold = 10.



[MinHash]

# This section contains parameters that control the MinHash/LowHash algorithm
# used to find alignment candidates.

# The number of consecutive markers that define a MinHash/LowHash feature.
m = 4

# This defines how low a hash has to be to be used with the LowHash algorithm.
hashFraction = 0.01

# The number of MinHash/LowHash iterations.
minHashIterationCount = 10
# The above value is suitable when using LowHash.
# The value below was the default for the MinHash algorithm.
# minHashIterationCount = 100

# The maximum bucket size to be used by the MinHash/LowHash algoritm.
# Buckets larger than this are ignored.
maxBucketSize = 10

# The minimum number of times a pair of oriented reads
# is found by the MinHash/LowHash algorithm for the pair to
# generate an overlap.
minFrequency = 2



[Align]

# This section contains parameters that control the alignment of
# oriented reads using an alignment graph.

# The maximum number of markers that an alignment is allowed
# to skip on either of the oriented reads being aligned.
maxSkip = 30

# Marker frequency threshold.
# When computing an alignment between two oriented reads,
# marker kmers that appear more than this number of times
# in either of the two oriented reads are discarded
# (in both oriented reads).
maxMarkerFrequency = 10

# The minimum number of aligned markers in an alignment
# in order for the alignment to be considered good and usable.
minAlignedMarkerCount = 100

# The maximum number of trim markers tolerated at the
# beginning and end of an alignment. There can be
# up this number of markers between the first/last aligned marker
# and the beginning/end of either oriented read
# for an alignment to be considered good and usable. 
maxTrim = 30



[ReadGraph]

# This section contains parameters that control
# the creation and processing of read graphs.

# The maximum alignments to be kept for each read.
maxAlignmentCount = 6

# The minimum size (number of oriented reads) of
# a connected component to be kept.
minComponentSize = 100

# Argument maxChimericReadDistance for flagChimericReads.
maxChimericReadDistance = 2



[MarkerGraph]

# This section contains parameters that control
# the creation and processing of the global marker graph.

# The minimum and maximum coverage (number of markers)
# for a vertex of the marker graph.
# Vertices with coverage outside this range are collapsed
# away and not generated by computeMarkerGraphVertices.
minCoverage = 10
maxCoverage = 100

# Parameters for flagMarkerGraphWeakEdges (transitive reduction).
lowCoverageThreshold = 0
highCoverageThreshold = 256
maxDistance = 30
edgeMarkerSkipThreshold = 100

# Number of iterations for pruneMarkerGraphStrongSubgraph.
pruneIterationCount = 6

# Maximum lengths (in markers) used at each iteration of
# simplifyMarkerGraph. Make sure there are no blanks,
# just commas.
simplifyMaxLength = 10,100,1000



[Assembly]

# This section contains parameters used during sequence assembly.

# Assembly strategy.
# Keep at default value 0. 
# Other options are under development and will not produce a usable assembly.
strategy = 0

# Maximum average edge coverage for a cross edge 
# of the assembly graph to be removed. 
crossEdgeCoverageThreshold = 3

markerGraphEdgeLengthThresholdForConsensus = 1000

# Do not change the the two parameters below except when testing
# some still experimental and undocumented features.
consensusCaller = Modal
useMarginPhase = False

# Set this to cause detailed coverage information to be stored.
# This can be used to calibrate the Bayesian model for repeat counts
# and for some types of analyses, but it slows down the assembly
# and uses additional huge page memory.
storeCoverageData = False



[Phasing]

# This sections contains options that control phasing.
# This functionality is under development and is
# only activated when Assembly.strategy is set to 1.
# This does not yet create useful assembly results
# and should not be used except for development.

# The minimum phasing similarity for an edge
# to be added to the phasing graph.
phasingSimilarityThreshold = 0.5

# The maximum number of phasing graph edges to be kept
# for each oriented read.
maxNeighborCount = 6

